To discuss with James (if he agrees):

1/ About the message:

Admit I was wrong about the message:

>> “The message of the author is that most unit testing is waste, that TDD is
>> mostly concerned with unit test, and that you should focus more on system and
>> regression testing.”

> No, TDD was only a minor sidelight.

OK, I was wrong. I was obsessing over TDD (because it radically changed the way
I think about software), and missed this. I apologize.

2/ Whee we agree

> a more mature approach emphasizes design, review and teamwork over tests

> live programs should be self-auditing (at least they should catch their own
> abnormal terminations) and send reports back to the author so fixes can be
> expedited

> Those days are gone, and I think we're in a mode where testing needs to
> continue forever, into the deployment of the product.

3/ Bug removal

> We know at least five other common techniques, each of which is about 3 times
> as efficient as unit testing in bug removal.

Care to elaborate?

4/ Assertions

As I said, I maintained a medium-sized Python project for years without
assertions. But maybe it depends on the langage.

However, I did tread any uncaught exception as a bug and a full backtrace
was made available for reports.

5/ TDD degrades coupling and cohesion

> It has again and again been empirically shown to degrade coupling and
> cohesion metrics in design

It's not what the paper you quoted says:

> Our results indicate that test-first programmers are more likely to write
> software in more and smaller units that are less complex and more highly
> tested.
> We weren’t able to confirm claims that TDD improves cohesion while
> lowering coupling,

To me, smaller, more classes and methods is orthogonal to coupling and
cohesion, and having smaller classes and shorter method is a good sign of code
quality, but I may be wrong.

> it encourages a bottom-up procedural structure rather than a cohesive object
> structure

That's where I don't agree.

Let's recap, and let's say you are using TDD with a bottom-up approach.

When doing TDD, you'll be writing lots of small functions and small classes,
just because you write short unit tests and thus short methods.

But you don't stop here. When the 'bottom' stuff works, you start going
'up', write higher-level tests, and start to think about object structure
since you're writing tests that involves several classes. At this point
you're no longer writing unit tests.

Also, let's not forget that you end every cycle of development with a
refactoring phase, so you do have time to think about coupling and cohesion.
