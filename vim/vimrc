let os=substitute(system('uname'), '\n', '', '')

packadd minpac

set runtimepath+=~/.fzf
" Add this repo too to runtimepath (so meta!)
execute 'set runtimepath+=' . expand('<sfile>:h')
" snippetsEmu needs 'after' in runtimepath too
execute 'set runtimepath+=' . expand('<sfile>:h') . '/after'

call minpac#init()
call minpac#add('k-takata/minpac', {'type': 'opt', 'branch': 'v1.0'})
call minpac#add('altercation/vim-colors-solarized')
call minpac#add('AndrewRadev/sideways.vim', { 'branch': 'v0.3.0' })
call minpac#add('andrewstuart/vim-kubernetes')
call minpac#add('bps/vim-textobj-python')
call minpac#add('dbmrq/vim-ditto')
call minpac#add('dleonard0/pony-vim-syntax')
call minpac#add('dmerejkowsky/fzf.vim')
call minpac#add('dmerejkowsky/vimbuddy.vim')
call minpac#add('dmerejkowsky/vim-ale')
call minpac#add('dmerejkowsky/vim-nerdtree')
call minpac#add('ervandew/supertab', { 'branch' : '2.1' })
call minpac#add('fatih/vim-go', { 'branch' : 'v1.10' })
call minpac#add('fs111/pydoc.vim', { 'branch' : '2.0' })
call minpac#add('godlygeek/tabular', { 'branch' : '1.0.0' })
call minpac#add('idanarye/vim-smile', { 'branch' : '1.0.1' })
call minpac#add('kana/vim-textobj-user',  { 'branch' : '0.7.1' })
call minpac#add('machakann/vim-highlightedyank')
call minpac#add('mbbill/undotree', { 'branch' : 'rel_4.3' })
call minpac#add('nanotech/jellybeans.vim', { 'branch' : 'v1.6' })
call minpac#add('peterhoeg/vim-qml')
call minpac#add('mileszs/ack.vim', { 'branch' : '1.0.9' })
call minpac#add('romainl/vim-cool')
call minpac#add('romainl/vim-qf', { 'branch' : '0.1.0' })
call minpac#add('scrooloose/nerdcommenter', { 'branch' : '2.3.0' })
call minpac#add('sheerun/vim-polyglot')
call minpac#add('tfnico/vim-gradle')
call minpac#add('tpope/vim-abolish', { 'branch' : 'v1.1' })
call minpac#add('tpope/vim-eunuch', { 'branch' : 'v1.1' })
call minpac#add('tpope/vim-fugitive', { 'branch' : 'v2.2' })
call minpac#add('tpope/vim-repeat', { 'branch' : 'v1.1' })
call minpac#add('tpope/vim-sleuth', { 'branch' : 'v1.1' })
call minpac#add('tpope/vim-surround', { 'branch' : 'v2.1' })
call minpac#add('vim-scripts/a.vim', { 'branch' : '2.18' })
call minpac#add('vim-scripts/snippetsEmu', { 'branch' : '1.2.3'})
call minpac#add('wellle/targets.vim', { 'branch' : 'v0.4.6'})


" Simple vim settings {{{1
syntax on
filetype plugin indent on
set history=10000
set mouse=a
if has("vim_starting")
  set encoding=utf-8
endif
set showcmd
set showmode
set ruler
set backspace=2
set virtualedit=block
set autowriteall
set shiftround
set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
set nrformats-=octal " don't go from 007 to 010
set hidden

if has("X11")
  set clipboard=unnamedplus
else
  set clipboard=unnamed
endif

let mapleader="\\"

set noswapfile
" Backups with persistent undos
set backup
let g:dotvim_backups=expand('$HOME') . '/.local/share/nvim/backups'
if ! isdirectory(g:dotvim_backups)
  call mkdir(g:dotvim_backups, "p")
endif
exec "set backupdir=" . g:dotvim_backups

if has('persistent_undo')
  set undofile
  set undolevels=1000
  set undoreload=10000
  exec "set undodir=" . g:dotvim_backups
endif

" Nicer scrolling
set scroll=5
set scrolloff=2

" This is nice if you have something
" that reset the title of you term at
" each command, otherwize it's annoying ...
set title

" Allow completion on filenames right after a '='.
" Uber-useful when editing bash scripts
set isfname-==

" Disable ex
nnoremap Q gq

" No more annoying bell
set visualbell t_vb=

" Disable useless ctrl+space behavior:
imap <Nul> <Space>

" Always display statusline
set laststatus=2

"For completion:
set wildmode=list:longest,full

set wildmenu
set wildignore=*.pyc

" smarter behavior of 'J' (join lines)
set nojoinspaces

" search settings
set hlsearch
set incsearch
set smartcase
set ignorecase

set inccommand=split

" Remove menu bar from GUI
let did_install_default_menus = 1

" I've always find it weird that it was not this way ...
set splitbelow

" More logical, but not vi-compatible
noremap Y y$
set gdefault
map Q gq

" Jump to last cursor position unless it's invalid or in an event handler
autocmd BufReadPost * call SetCursorPosition()
function! SetCursorPosition()
  if &filetype !~ 'git'
    if line("'\"") > 0 && line("'\"") <= line("$")
      exe "normal! g`\""
      normal! zz
    endif
  endif
endfunction

" Always load those useful plugins:
runtime! macros/matchit.vim

" These are overloaded in the various ftplugin/ scripts
set shiftwidth=2
set expandtab
set smarttab
set smartindent
set tabstop=4

" Colors {{{1
if os == "Darwin"
  set background=light
  colorscheme default
else
  colorscheme jellybeans
endif

" Custom functions {{{1
" Remove trailing whitespace
function! CleanWhiteSpace()
  let l = line(".")
  let c = col(".")
  :%s/\s\+$//e
  let last_search_removed_from_history = histdel('s', -1)
  call cursor(l, c)
endfunction()

function! RemoveBlankLinesAtTheEndOfFile()
  let l = line(".")
  let c = col(".")
  :%s#\($\n\s*\)\+\%$##e
  let last_search_removed_from_history = histdel('s', -1)
  call cursor(l, c)
endfunction()

command! -nargs=0 CleanWhiteSpace :call CleanWhiteSpace()
command! -nargs=0 RemoveBlankLinesAtTheEndOfFile :call RemoveBlankLinesAtTheEndOfFile()

function! ListWorkingDirs()
  call fzf#run({
        \ 'source': "cwd-history list",
        \ 'sink': "tcd",
        \ 'options': "--exact"
        \})
endfunction

function! Try(name)
  call minpac#add(a:name)
  call minpac#update()
endfunction

command! -nargs=1 Try :call Try(<f-args>)

command! -nargs=0 ListWorkingDirs :call ListWorkingDirs()
nnoremap <leader>l :ListWorkingDirs<CR>


" Convert DOS line endings to UNIX line endings

function! FromDos()
  %s/\r//e
endfunction

command! FromDos call FromDos()

" Used to create missing directories before writing a
" buffer
function! MkdirP()
  :!mkdir -p %:h
endfunction

command! MkdirP call MkdirP()

" Plugins customizations {{{1

" Tell ALE to:
" * only run on file save
" * use the quickfix only
let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_enter = 0
let g:ale_set_loclist = 1
let g:ale_set_quickfix = 0
let g:ale_echo_cursor = 1
" vim-ale flow eats all my inotify slots :/
let g:ale_linters = {
  \ 'c': [],
  \ 'cpp': [],
  \ 'python': ['pychecksyntax', 'pycodestyle', 'pyflakes'],
  \ 'java': [],
  \ 'javascript': ['eslint'],
  \ }
let g:ale_set_highlights = 0


let g:ale_rust_cargo_use_check = 1

" Tell snippy to use <C-Space> (tab conflicts with Supertab)
let g:snippetsEmu_key = "<C-Space>"

" Status line (requires VimBuddy plugin to be present)
set statusline=%{VimBuddy()}\ [%n]\ %<%f\ %{fugitive#statusline()}%h%m%r%=%-14.(%l,%c%V%)\ %P\ %a

" Fix go syntax file:
let g:go_highlight_array_whitespace_error=0
let g:go_highlight_chan_whitespace_error=0
let g:go_highlight_extra_types=0
let g:go_highlight_space_tab_error=0
let g:go_highlight_trailing_whitespace_error=0

" goimports is just a nicer `go fmt` ...
let g:go_fmt_command = "goimports"

" Tell the python plugin loaded by vim-polyglot to not
" highlight space errors.
" Most of the times they are trailing white spaces, and
" both the CleanWhiteSpace function and the pycodestyle linter
" will take care of those.
let g:python_highlight_space_errors=0

let g:rustfmt_autosave=1
" to not conflict with vim-ale
let g:rustfmt_fail_silently = 1

if os == 'Linux'
  let g:netrw_browsex_viewer= "xdg-open"
else
endif

" Sideways
nnoremap <c-h> :SidewaysLeft<cr>
nnoremap <c-l> :SidewaysRight<cr>

" Use the lazy git-fpush command
function! Gfpush()
  w
  !git fpush %
endfunction

command! Gfpush call Gfpush()

" Quit Gdiff mode
function! GdiffOff()
  diffoff
endfunction

command! GdiffOff call GdiffOff()

" there's already an Ag coming from fzf, but I want
" a quickfix instead.
" ag.vim is dead, so I use ack.vim and these mappings:
let g:ackprg="rg --vimgrep"

" Autocommands {{{1
" Remove trailing whitespaces when saving:
augroup whitespaceclean
  autocmd!
  autocmd BufWritePre * :CleanWhiteSpace
  autocmd BufWritePre * :RemoveBlankLinesAtTheEndOfFile
augroup end

" Spell checking
augroup spell
  autocmd!
  autocmd filetype rst  :setlocal spell spelllang=en
  autocmd filetype tex  :setlocal spell spelllang=en
  autocmd filetype markdown :setlocal spell spelllang=en
  autocmd filetype gitcommit  :setlocal spell spelllang=en
augroup end


" Special settings from vim files
augroup filetype_vim
  autocmd!
  autocmd filetype vim setlocal foldmethod=marker
  autocmd BufWritePre *.vim :source %
augroup END

" Register more extension for the zip plugin
autocmd BufReadCmd *.aar,*.apk,*.jar,*pkg,*.whl call zip#Browse(expand("<amatch>"))


" Write cwd when leaving
function! WriteCWD()
  call writefile([getcwd()], "/tmp/nvim-cwd")
endfunction

autocmd VimLeave * silent call WriteCWD()


" Mapping and abbreviations {{{1

nnoremap <leader>n :windo :set number!<CR>
nnoremap <leader>tb :tabnew<space>
nnoremap <leader>t :GFiles<CR>
nnoremap <leader>T :Files<CR>
nnoremap <leader>p :History<CR>
nnoremap <leader>b :Buffers<CR>

nnoremap <A-p> :lprevious<CR>
nnoremap <A-n> :lnext<CR>
nnoremap <A-r> :lrewind<CR>

" Some magic from romainl
for char in [ '-', '_', '.', '/']
  execute 'xnoremap i' . char . ' :<C-u>normal! T' . char . 'vt' . char . '<CR>'
  execute 'onoremap i' . char . ' :normal vi' . char . '<CR>'
  execute 'xnoremap a' . char . ' :<C-u>normal! F' . char . 'vf' . char . '<CR>'
  execute 'onoremap a' . char . ' :normal va' . char . '<CR>'
endfor

"nore typing :make is much too long anyway
nnoremap <leader>m :make<cr>
nnoremap <leader>M :w<cr>:Neomake!<cr>

" select text that was just pasted
nnoremap gp `[v`]
" same, but go to the opposite end of what was just pasted
nnoremap gP `]


" ctrl-^
nnoremap <leader><leader> <c-^>

" Simpler way to go to normal mode from insert mode
inoremap jj <Esc>


" it's easy to type :X by mistake, and the 'encrypt'
" feature is useless anyway
nnoremap :X :x

" use begging-of-history inside command mode
" with ctrl+n ctrl+p
cnoremap <C-N> <Down>
cnoremap <C-P> <Up>
cnoremap %% <C-R>=expand('%h').'/'<cr>

" 'cd' towards the dir in which the current file is edited
" but only change the path for the current tab
function! CdInCurrentBuf()
  let current_buf_name = bufname("%")
  if current_buf_name =~ "NERD_tree_"
    let l:path = b:NERDTreeRoot.path.str()
    :execute "tcd" . l:path
  else
    :tcd %:h
  endif

endfunction()
noremap <leader>cd :call CdInCurrentBuf()<CR>

" Open files located in the same dir in with the current file is edited
nnoremap <leader>ew :e <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>es :sp <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>ev :vsp <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>et :tabe <C-R>=expand("%:p:h") . "/" <CR>

" Create the file under the cursor (when gf complains)
nnoremap <leader>gf :e<cfile><CR>


" Man page for work under cursor
nnoremap K :Man <cword> <CR>

" Spell check
cnoremap spc setlocal spell spelllang=

" Dragging visual blocks
vnoremap  <expr>  <LEFT>   DVB_Drag('left')
vnoremap  <expr>  <RIGHT>  DVB_Drag('right')
vnoremap  <expr>  <DOWN>   DVB_Drag('down')
vnoremap  <expr>  <UP>     DVB_Drag('up')
vnoremap  <expr>  D        DVB_Duplicate()

" don't try to remove whitespace, :w will do it
let g:DVB_TrimWS=0

" Escape from terminal mode by pressing escape
tnoremap <Esc> <C-\><C-n>

" CWD and tab stuff {{{1
let g:NERDTreeHijackNetrw = 1
let g:NERDTreeQuitOnOpen = 1
let g:NERDTreeChDirMode = 2

function! ToggleNerdTreeInPlace(path)
  if bufname("%") =~ "NERD_tree_"
    :normal `N
  else
    " create a mark so that we can go back later
    :normal mN
    :execute "NERDTree " . a:path
  endif
endfunction

nnoremap <leader>R :call ToggleNerdTreeInPlace(getcwd())<cr>
nnoremap <leader>r :NERDTree<space>

" }}}
