" Vim Plug {{{1

call plug#begin(expand('~/.local/share/nvim/bundle'))

" Add this repo to the list:
Plug  expand('<sfile>:h')

" And fzf:
set rtp+=~/.fzf

" Other plugins from github
Plug 'benekastah/neomake'
Plug 'blueyed/vim-diminactive', { 'commit' : 'fce5469baa086ae4b72622dc1f81eda26df36e95'}
Plug 'bps/vim-textobj-python', { 'commit' : '83c97d9aaae74a7c35b092bae59ef5339723dd9b'}
Plug 'dleonard0/pony-vim-syntax'
Plug 'dmerejkowsky/fzf.vim'
Plug 'dmerejkowsky/vim-nerdtree'
Plug 'ervandew/supertab', { 'tag' : '2.1' }
Plug 'fatih/vim-go', { 'tag' : 'v1.10' }
Plug 'fs111/pydoc.vim', { 'tag' : '2.0' }
Plug 'gavinbeatty/dragvisuals.vim', { 'commit' : 'b6e6d418faf3ec8c40e49c099f82481c820ab098'}
Plug 'godlygeek/tabular', { 'commit' : '60f25648814f0695eeb6c1040d97adca93c4e0bb' }
Plug 'idanarye/vim-smile', { 'tag' : '1.0.1' }
Plug 'kana/vim-textobj-user',  { 'tag' : '0.7.1' }
Plug 'mbbill/undotree', { 'tag' : 'rel_4.3' }
Plug 'peterhoeg/vim-qml'
Plug 'rking/ag.vim', { 'commit' : 'f755abfb1c4e4e3f59f6cfa25ce16edb5af9e516' }
Plug 'romainl/vim-dichromatic', { 'branch' : 'wip' }
Plug 'romainl/vim-qf', { 'branch' : '0.1.0' }
Plug 'rust-lang/rust.vim'
Plug 'scrooloose/nerdcommenter', { 'tag' : '2.3.0' }
Plug 'tfnico/vim-gradle'
Plug 'tpope/vim-abolish', { 'tag' : 'v1.1' }
Plug 'tpope/vim-eunuch', { 'tag' : 'v1.1' }
Plug 'tpope/vim-fugitive', { 'tag' : 'v2.2' }
Plug 'tpope/vim-repeat', { 'rev' : 'v1.1' }
Plug 'tpope/vim-sleuth', { 'rev' : '1.1' }
Plug 'tpope/vim-surround', { 'tag' : 'v2.1' }
Plug 'vim-scripts/a.vim', { 'tag' : '2.18' }
Plug 'vim-scripts/indentpython.vim', { 'tag' : '0.3' }
Plug 'vim-scripts/snippetsEmu', { 'tag' : '1.2.3'}
if has("python")
  Plug 'mutewinter/swap-parameters', { 'commit' : '1e68c6bdf399b05449781e0dd8342086c97380b7'}
endif
Plug 'yannicklm/vim-send-cmd'
Plug 'yannicklm/vimbuddy.vim'

call plug#end()

" Simple vim settings {{{1
syntax on
filetype plugin indent on
set history=10000
set mouse=a
if has("vim_starting")
  set encoding=utf-8
endif
set showcmd
set showmode
set ruler
set backspace=2
set virtualedit=block
set autowriteall
set shiftround
set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
set nrformats-=octal " don't go from 007 to 010
set hidden

if has("X11")
  set clipboard=unnamedplus
else
  set clipboard=unnamed
endif

let mapleader=","

" Backups with persistent undos
set backup
let g:dotvim_backups=expand('$HOME') . '/.local/share/nvim/backups'
if ! isdirectory(g:dotvim_backups)
  call mkdir(g:dotvim_backups, "p")
endif
exec "set backupdir=" . g:dotvim_backups

if has('persistent_undo')
  set undofile
  set undolevels=1000
  set undoreload=10000
  exec "set undodir=" . g:dotvim_backups
endif

" Nicer scrolling
set scroll=5
set scrolloff=2

" This is nice if you have something
" that reset the title of you term at
" each command, otherwize it's annoying ...
set title

" Allow completion on filenames right after a '='.
" Uber-useful when editing bash scripts
set isfname-==

" Disable ex
nnoremap Q gq

" No more annoying bell
set visualbell t_vb=

" Disable useless ctrl+space behavior:
imap <Nul> <Space>

" Always display statusline
set laststatus=2

"For completion:
set wildmode=list:longest,full

set wildmenu
set wildignore=*.pyc

" smarter behavior of 'J' (join lines)
set nojoinspaces

" search settings
set nohlsearch
set incsearch
set ignorecase
set smartcase

" Remove menu bar from GUI
let did_install_default_menus = 1

" I've always find it weird that it was not this way ...
set splitbelow

" More logical, but not vi-compatible
noremap Y y$
set gdefault
map Q gq

" Jump to last cursor position unless it's invalid or in an event handler
autocmd BufReadPost * call SetCursorPosition()
function! SetCursorPosition()
  if &filetype !~ 'git'
    if line("'\"") > 0 && line("'\"") <= line("$")
      exe "normal! g`\""
      normal! zz
    endif
  endif
endfunction
" Always load those useful plugins:
runtime! macros/matchit.vim
if ! has("nvim")
  runtime! ftplugin/man.vim
endif

" These are overloaded in the various ftplugin/ scripts
set shiftwidth=2
set expandtab
set smarttab
set smartindent
set tabstop=4

" Colors {{{1
let os=substitute(system('uname'), '\n', '', '')
" has('mac') only works on macvim ...
if os == 'Darwin' || os == 'Mac'
  set background=light
else
  se background=dark
  " To work with vim-diminish, active window will be the transparent one:
  hi ColorColumn ctermbg=0
endif

" Custom functions {{{1
" Remove trailing whitespace
function! CleanWhiteSpace()
  let l = line(".")
  let c = col(".")
  :%s/\s\+$//e
  let last_search_removed_from_history = histdel('s', -1)
  call cursor(l, c)
endfunction()

function! RemoveBlankLinesAtTheEndOfFile()
  let l = line(".")
  let c = col(".")
  :%s#\($\n\s*\)\+\%$##e
  let last_search_removed_from_history = histdel('s', -1)
  call cursor(l, c)
endfunction()

command! -nargs=0 CleanWhiteSpace :call CleanWhiteSpace()
command! -nargs=0 RemoveBlankLinesAtTheEndOfFile :call RemoveBlankLinesAtTheEndOfFile()

function ListWorkingDirs()
  call fzf#run({
        \ 'source': "cwd-history list",
        \ 'sink': "cd"
        \})
endfunction

command! -nargs=0 ListWorkingDirs :call ListWorkingDirs()
nnoremap <leader>l :ListWorkingDirs<CR>


" Convert DOS line endings to UNIX line endings

function! FromDos()
  %s/\r//e
endfunction

command! FromDos call FromDos()

" Used to create missing directories before writing a
" buffer
function! MkdirP()
  :!mkdir -p %:h
endfunction

command! MkdirP call MkdirP()

" Plugins customizations {{{1

" Tell snippy to use <C-Space> (tab conflicts with Supertab)
let g:snippetsEmu_key = "<C-Space>"



" Status line (requires VimBuddy plugin to be present)
set statusline=%{VimBuddy()}\ [%n]\ %<%f\ %{fugitive#statusline()}%h%m%r%=%-14.(%l,%c%V%)\ %P\ %a

" Fix go syntax file:
let g:go_highlight_array_whitespace_error=0
let g:go_highlight_chan_whitespace_error=0
let g:go_highlight_extra_types=0
let g:go_highlight_space_tab_error=0
let g:go_highlight_trailing_whitespace_error=0

" goimports is just a nicer `go fmt` ...
let g:go_fmt_command = "goimports"

" Use the lazy git-fpush command
function! Gfpush()
  w
  !git fpush %
endfunction

command! Gfpush call Gfpush()

" Quit Gdiff mode
function! GdiffOff()
  diffoff
endfunction

command! GdiffOff call GdiffOff()

" Autocommands {{{1
" Remove trailing whitespaces when saving:
augroup whitespaceclean
  autocmd!
  autocmd BufWritePre * :CleanWhiteSpace
  autocmd BufWritePre * :RemoveBlankLinesAtTheEndOfFile
augroup end

" Spell checking
augroup spell
  autocmd!
  autocmd filetype rst  :setlocal spell spelllang=en
  autocmd filetype tex  :setlocal spell spelllang=en
  autocmd filetype markdown :setlocal spell spelllang=en
  autocmd filetype gitcommit  :setlocal spell spelllang=en
augroup end


" Special settings from vim files
augroup filetype_vim
  autocmd!
  autocmd filetype vim setlocal foldmethod=marker
  autocmd BufWritePre *.vim :source %
augroup END

" Register more extension for the zip plugin
autocmd BufReadCmd *.aar,*.apk,*.jar,*pkg,*.whl call zip#Browse(expand("<amatch>"))


" Write cwd when leaving
function! WriteCWD()
  call writefile([getcwd()], "/tmp/nvim-cwd")
endfunction

autocmd VimLeave * silent call WriteCWD()


" Mapping and abbreviations {{{1


nnoremap <leader>t :GFiles<CR>
nnoremap <leader>p :History<CR>
nnoremap <leader>b :Buffers<CR>

" Some magic from romainl
for char in [ '_', '.', '/']
  execute 'xnoremap i' . char . ' :<C-u>normal! T' . char . 'vt' . char . '<CR>'
  execute 'onoremap i' . char . ' :normal vi' . char . '<CR>'
  execute 'xnoremap a' . char . ' :<C-u>normal! F' . char . 'vf' . char . '<CR>'
  execute 'onoremap a' . char . ' :normal va' . char . '<CR>'
endfor

"nore typing :make is much too long anyway
nnoremap <leader>m :make<cr>
nnoremap <leader>M :w<cr>:Neomake!<cr>

" select text that was just pasted
nnoremap gp `[v`]
" same, but go to the opposite end of what was just pasted
nnoremap gP `]


" ctrl-^
nnoremap <leader><leader> <c-^>

" Simpler way to go to normal mode from insert mode
inoremap jj <Esc>

" « it's one less key to hit every time I want to save a file »
"     -- Steve Losh (again)
nnoremap ; :
vnoremap ; :

" it's easy to type :X by mistake, and the 'encrypt'
" feature is useless anyway
nnoremap :X :x

" use begging-of-history inside command mode
" with ctrl+n ctrl+p
cnoremap <C-N> <Down>
cnoremap <C-P> <Up>
cnoremap %% <C-R>=expand('%h').'/'<cr>

" 'cd' towards the dir in which the current file is edited
" but only change the path for the current window
noremap <leader>cd :lcd %:h<CR>

" Open files located in the same dir in with the current file is edited
nnoremap <leader>ew :e <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>es :sp <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>ev :vsp <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>et :tabe <C-R>=expand("%:p:h") . "/" <CR>

" Create the file under the cursor (when gf complains)
nnoremap <leader>gf :e<cfile><CR>

" Navigate through the buffer's list with alt+up, alt+down
nnoremap <M-Down>  :bp<CR>
nnoremap <M-Up>    :bn<CR>

" Man page for work under cursor
nnoremap K :Man <cword> <CR>

" Spell check
cnoremap spc setlocal spell spelllang=

" Dragging visual blocks
vnoremap  <expr>  <LEFT>   DVB_Drag('left')
vnoremap  <expr>  <RIGHT>  DVB_Drag('right')
vnoremap  <expr>  <DOWN>   DVB_Drag('down')
vnoremap  <expr>  <UP>     DVB_Drag('up')
vnoremap  <expr>  D        DVB_Duplicate()

" don't try to remove whitespace, :w will do it
let g:DVB_TrimWS=0

" Escape from terminal mode by pressing escape
if has("nvim")
  tnoremap <Esc> <C-\><C-n>
endif

" CWD and tab stuff {{{1
let g:NERDTreeHijackNetrw = 0
let g:NERDTreeQuitOnOpen = 1

if has("nvim")
  function! OnTabEnter(newpath)
    if isdirectory(a:newpath)
      " If it's a directory,set working dir
      " and open NERDTree right away
      :execute "tcd " . a:newpath
      :call nerdtree#checkForBrowse(a:newpath)
    else
      " else, just set working directory
      let dirname = fnamemodify(a:newpath, ":h")
      :execute "tcd " . dirname
    endif
  endfunction

  autocmd TabNewEntered * call OnTabEnter(expand("<amatch>"))
endif

function! ToggleNerdTreeInPlace(path)
  if bufname("%") =~ "NERD_tree_"
    :normal `N
  else
    " create a mark so that we can go back later
    :normal mN
    :execute "NERDTree " . a:path
  endif
endfunction

" TabNewWithCWD: just call :tabnew on neovim,
" but use :lcd on vim where TabNewEntered event does
" not exist
function! TabNewWithCWD(newpath)
  :execute "tabnew " . a:newpath
  if ! has("nvim")
    if isdirectory(a:newpath)
      :execute "lcd " . a:newpath
      NerdTreeInPlace(a:newpath)
    else
      let dirname = fnamemodify(a:newpath, ":h")
      :execute "lcd " . dirname
    endif
  endif
endfunction

" Shortcut with :Tb:
command! -nargs=1 -complete=file TabNew :call TabNewWithCWD("<args>")
cnoremap Tb TabNew <Space>


nnoremap <leader>r :call ToggleNerdTreeInPlace(getcwd())<cr>

" }}}
